# 🐳 复杂依赖关系场景的Docker Compose配置示例
# 注意：这个文件演示了服务间的依赖关系如何在Playbook中处理
# Playbook会自动根据metadata.yml中的depends_on字段确定部署批次

version: '3.8'

services:
  # 📊 Batch 1: 基础服务层
  redis:
    image: "${REDIS_IMAGE}:${REDIS_TAG}"
    container_name: "${REDIS_CONTAINER_NAME}"
    ports:
      - "${REDIS_HOST_PORT}:${REDIS_CONTAINER_PORT}"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 10s
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  mysql:
    image: "${MYSQL_IMAGE}:${MYSQL_TAG}"
    container_name: "${MYSQL_CONTAINER_NAME}"
    ports:
      - "${MYSQL_HOST_PORT}:${MYSQL_CONTAINER_PORT}"
    environment:
      MYSQL_ROOT_PASSWORD: "${MYSQL_ROOT_PASSWORD}"
      MYSQL_DATABASE: "${MYSQL_DATABASE}"
      MYSQL_USER: "${MYSQL_USER}"
      MYSQL_PASSWORD: "${MYSQL_PASSWORD}"
    volumes:
      - mysql_data:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 15s
      timeout: 10s
      retries: 5
      start_period: 60s
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  config-service:
    image: "${CONFIG_SERVICE_IMAGE}:${CONFIG_SERVICE_TAG}"
    container_name: "${CONFIG_SERVICE_CONTAINER_NAME}"
    ports:
      - "${CONFIG_SERVICE_HOST_PORT}:${CONFIG_SERVICE_CONTAINER_PORT}"
    volumes:
      - ./config:/usr/share/nginx/html:ro
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/health"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 5s
    restart: unless-stopped

  # 📊 Batch 2: 应用服务层 (依赖Batch 1)
  # 注意：Docker Compose的depends_on只控制启动顺序，不等待服务就绪
  # Playbook的depends_on会等待依赖服务完全就绪（包括健康检查）
  user-service:
    image: "${USER_SERVICE_IMAGE}:${USER_SERVICE_TAG}"
    container_name: "${USER_SERVICE_CONTAINER_NAME}"
    ports:
      - "${USER_SERVICE_HOST_PORT}:${USER_SERVICE_CONTAINER_PORT}"
    environment:
      REDIS_URL: "${REDIS_URL}"
      DATABASE_URL: "${DATABASE_URL}"
      CONFIG_SERVICE_URL: "${CONFIG_SERVICE_URL}"
    # Docker Compose的depends_on（启动顺序依赖）
    depends_on:
      - redis
      - mysql
      - config-service
    # Playbook的depends_on在metadata.yml中定义（就绪状态依赖）
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 20s
      timeout: 10s
      retries: 5
      start_period: 90s
    restart: unless-stopped

  order-service:
    image: "${ORDER_SERVICE_IMAGE}:${ORDER_SERVICE_TAG}"
    container_name: "${ORDER_SERVICE_CONTAINER_NAME}"
    ports:
      - "${ORDER_SERVICE_HOST_PORT}:${ORDER_SERVICE_CONTAINER_PORT}"
    environment:
      REDIS_URL: "${REDIS_URL}"
      DATABASE_URL: "${DATABASE_URL}"
      USER_SERVICE_URL: "${USER_SERVICE_URL}"
    depends_on:
      - redis
      - mysql
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 20s
      timeout: 10s
      retries: 5
      start_period: 90s
    restart: unless-stopped

  # 📊 Batch 3: 网关层 (依赖Batch 1和2)
  api-gateway:
    image: "${API_GATEWAY_IMAGE}:${API_GATEWAY_TAG}"
    container_name: "${API_GATEWAY_CONTAINER_NAME}"
    ports:
      - "${API_GATEWAY_HOST_PORT}:${API_GATEWAY_CONTAINER_PORT}"
    environment:
      USER_SERVICE_URL: "${USER_SERVICE_URL}"
      ORDER_SERVICE_URL: "${ORDER_SERVICE_URL}"
      CONFIG_SERVICE_URL: "${CONFIG_SERVICE_URL}"
    depends_on:
      - user-service
      - order-service
      - config-service
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/api/health"]
      interval: 15s
      timeout: 10s
      retries: 8
      start_period: 60s
    restart: unless-stopped

  # 📊 Batch 4: 前端层 (依赖Batch 3)
  web-frontend:
    image: "${WEB_FRONTEND_IMAGE}:${WEB_FRONTEND_TAG}"
    container_name: "${WEB_FRONTEND_CONTAINER_NAME}"
    ports:
      - "${WEB_FRONTEND_HOST_PORT}:${WEB_FRONTEND_CONTAINER_PORT}"
    environment:
      API_GATEWAY_URL: "${API_GATEWAY_URL}"
    depends_on:
      - api-gateway
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 30s
    restart: unless-stopped

  mobile-app-backend:
    image: "${MOBILE_BACKEND_IMAGE}:${MOBILE_BACKEND_TAG}"
    container_name: "${MOBILE_BACKEND_CONTAINER_NAME}"
    ports:
      - "${MOBILE_BACKEND_HOST_PORT}:${MOBILE_BACKEND_CONTAINER_PORT}"
    environment:
      API_GATEWAY_URL: "${API_GATEWAY_URL}"
    depends_on:
      - api-gateway
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 30s
    restart: unless-stopped

# 💾 数据持久化
volumes:
  redis_data:
    driver: local
  mysql_data:
    driver: local

# 🌐 网络配置
networks:
  default:
    name: ${NETWORK_NAME}
    driver: bridge

# 📝 重要说明：
#
# 🔄 依赖关系的两个层面：
# 1. Docker Compose depends_on: 控制容器启动顺序，但不等待服务就绪
# 2. Playbook depends_on: 等待服务完全就绪（健康检查通过）后才启动依赖方
#
# 🚀 并发部署的优势：
# - 传统方式：逐个启动服务，总时间 = 所有服务启动时间之和
# - 并发方式：批次内并发，总时间 = 各批次最大启动时间之和
#
# 🎯 最佳实践：
# 1. 合理设计服务依赖关系，避免过深的依赖链
# 2. 基础服务（redis、mysql）尽量无依赖，可以并发启动
# 3. 应用服务层可以依赖基础服务，在同一批次内并发
# 4. 网关和前端服务依赖应用服务，形成清晰的分层架构